COM Library

a basic concept to have DEBUG and COMMAND/ANSWER 

channel defintions

SOF Protocoll          Length          Data             eof
a   ASCII command   ASCII:0000      data-ASCII(length)  A
b   BIN command     binary(32-bit)  data-bin(length)    B
d   debug           ASCII:length    data-ASCII(length)  D



command structure (data section)  for a&b

Field  Length   Comment
W/R/A  1 Byte   read, write, answer command
ADR    0-255    Adresse of sub device
IDX    0-65535  index for command
data   xx       data fro command  size = length - 4  (could be 0)


ADR table:

00: broadcast
10: SWITCH-0
11: SWITCH-1  
20: PWM_RGB
30: WS2812  - 0
31: WS2812  - 1
32: WS2812  - 2
33: WS2812  - 3

commands Broadcast:

------+-----------+---------------+-------+-----------+----------------------------------------
IDX   | name      | length data   | byte  | name      | Values
------+-----------+---------------+-------+-----------+----------------------------------------
0       ON_OFF      1 Byte          0       state       0(def): all off    
                                                        1: all on
------+-----------+---------------+-------+-----------+----------------------------------------
1       trigger     2 bytes         0.1     Trigger bit field
                                                        Bit 0: Band 0    
                                                        Bit 15: Band 15  
                                                        0 = trigger for no band
------+-----------+---------------+-------+-----------+----------------------------------------
50      self-test   1 byte          0       state       0(def): off    
                                                        1: on
------+-----------+---------------+-------+-----------+----------------------------------------



commands Switch:                    
------+-----------+---------------+-------+-----------+----------------------------------------
IDX   | name      | length data   | byte  | name      | Values
------+-----------+---------------+-------+-----------+----------------------------------------
0       DIM         1 Byte          0       dim value   0(def,off) .. 255
------+-----------+---------------+-------+-----------+----------------------------------------
1       config      10 Bytes        0       mode        0(def): continous
                                                        1: flash single
                                                        2: flash triggered
                                                        2: flash sequence
                                                        4: flash sequence triggered
                                    1       ramp        0(def) no ramp
                                    2..3    time        flash time in [ms]  def = 50ms
                                    4..5    trigger     set trigger band 0..15, def 0 = no band
                                    6..7    count       sequence counter  def = 3
                                    8..9    pause       sequence pause time [ms] def = 50
------+-----------+---------------+-------+-----------+----------------------------------------


commands PWM RGB:
------+-----------+---------------+-------+-----------+----------------------------------------
IDX   | name      | length data   | byte  | name      | Values
------+-----------+---------------+-------+-----------+----------------------------------------
0       DIM         1 Byte          0       dim value   0(def,off) .. 255
------+-----------+---------------+-------+-----------+----------------------------------------
1       config      10 Bytes        0       mode        0(def): continous
                                                        1: flash single
                                                        2: flash triggered
                                                        2: flash sequence
                                                        4: flash sequence triggered
                                                        5: rainbow
                                                        6: Blaulicht
                                    1       ramp        0(def) no ramp
                                    2..3    time        flash time in [ms]  def = 50ms
                                    4..5    trigger     set trigger band 0..15, def 0 = no band
                                    6..7    count       sequence counter  def = 3
                                    8..9    pause       sequence pause time [ms] def = 50
------+-----------+---------------+-------+-----------+----------------------------------------
2       color       3 Bytes         0       R value     0..255  (will be scaled with dim)
                                    1       G value     0..255  (will be scaled with dim) 
                                    2       B value     0..255  (will be scaled with dim)
                                    






commands WS2812:






















// ArduinoTrace - github.com/bblanchon/ArduinoTrace
// Copyright Benoit Blanchon 2018-2021
// MIT License
//
// A simple tracing macro to debug you program.
//
// Recipe to find where the code crashes:
//  1. sprinkle your code with TRACE()
//  2. run the program
//  3. view all traces in the Serial monitor
//
// Each trace includes the:
//  * the filename
//  * the line number
//  * the current function
//  * the template parameters (if any)

#pragma once

#include <Arduino.h>

#ifndef ARDUINOTRACE_ENABLE
#define ARDUINOTRACE_ENABLE 1
#endif

#if ARDUINOTRACE_ENABLE == 1

#ifndef ARDUINOTRACE_SERIAL
#define ARDUINOTRACE_SERIAL Serial
#endif

#ifndef ARDUINOTRACE_ENABLE_PROGMEM
#ifdef PROGMEM
#define ARDUINOTRACE_ENABLE_PROGMEM 1
#else
#define ARDUINOTRACE_ENABLE_PROGMEM 0
#endif
#endif

#ifndef ARDUINOTRACE_ENABLE_FULLPATH
#define ARDUINOTRACE_ENABLE_FULLPATH 0
#endif

#ifndef ARDUINOTRACE_FUNCTION_NAME_IN_FLASH
#if defined(ESP8266)
#define ARDUINOTRACE_FUNCTION_NAME_IN_FLASH 1
#else
#define ARDUINOTRACE_FUNCTION_NAME_IN_FLASH 0
#endif
#endif

namespace ArduinoTrace {
constexpr size_t strlen(const char *str) {
  return str[0] ? strlen(str + 1) + 1 : 0;
}

template <char... chars>
struct string {
#if ARDUINOTRACE_ENABLE_PROGMEM
  const __FlashStringHelper *data() {
    static const char buffer[] PROGMEM = {chars...};
    return reinterpret_cast<const __FlashStringHelper *>(buffer);
  }
#else
  const char *data() {
    static const char buffer[] = {chars...};
    return buffer;
  }
#endif
};

template <typename TSourceString, size_t remainingLength,
          char... collectedChars>
struct string_maker {
  using result =
      typename string_maker<TSourceString, remainingLength - 1,
                            TSourceString::data()[remainingLength - 1],
                            collectedChars...>::result;
};

#if ARDUINOTRACE_ENABLE_FULLPATH == 0
template <typename TSourceString, size_t remainingLength,
          char... collectedChars>
struct string_maker<TSourceString, remainingLength, '/', collectedChars...> {
  using result = string<collectedChars..., '\0'>;
};

template <typename TSourceString, size_t remainingLength,
          char... collectedChars>
struct string_maker<TSourceString, remainingLength, '\\', collectedChars...> {
  using result = string<collectedChars..., '\0'>;
};
#endif

template <typename TSourceString, char... collectedChars>
struct string_maker<TSourceString, 0, collectedChars...> {
  using result = string<collectedChars..., '\0'>;
};

template <typename TStringSource>
using make_string =
    typename string_maker<TStringSource, strlen(TStringSource::data())>::result;

struct Initializer {
  template <typename TSerial>
  Initializer(TSerial &serial, int bauds) {
    serial.begin(bauds);
    while (!serial) continue;
  }
};

template <typename TFilename, typename TPrefix>
struct Printer {
  template <typename TSerial, typename TValue>
  Printer(TSerial &serial, const TValue &content) {
    serial.print(make_string<TFilename>{}.data());
    serial.print(make_string<TPrefix>{}.data());
    serial.println(content);
    serial.flush();
  }
};

template <typename TSerial>
inline void pause(TSerial &serial) {
  while (serial.read() != '\n') delay(10);
}
}  // namespace ArduinoTrace

#define ARDUINOTRACE_STRINGIFY(X) #X
#define ARDUINOTRACE_CONCAT(X, Y) X##Y

#if ARDUINOTRACE_ENABLE_PROGMEM
#define ARDUINOTRACE_FLASHIFY(X) F(X)
#else
#define ARDUINOTRACE_FLASHIFY(X) X
#endif

#if ARDUINOTRACE_FUNCTION_NAME_IN_FLASH
#define ARDUINOTRACE_FUNCTION_NAME \
  reinterpret_cast<const __FlashStringHelper *>(__PRETTY_FUNCTION__)
#else
#define ARDUINOTRACE_FUNCTION_NAME __PRETTY_FUNCTION__
#endif

#define ARDUINOTRACE_PRINT(id, file, prefix, content)                         \
  {                                                                           \
    struct __filename {                                                       \
      constexpr static char const *data() { return file; }                    \
    };                                                                        \
    struct __prefix {                                                         \
      constexpr static char const *data() { return prefix; }                  \
    };                                                                        \
    ArduinoTrace::Printer<__filename, __prefix> __tracer(ARDUINOTRACE_SERIAL, \
                                                         content);            \
  }

#define ARDUINOTRACE_INITIALIZE(id, bauds)                          \
  ArduinoTrace::Initializer ARDUINOTRACE_CONCAT(__initializer, id)( \
      ARDUINOTRACE_SERIAL, bauds);

#define ARDUINOTRACE_TRACE_PREFIX(line) ":" ARDUINOTRACE_STRINGIFY(line) ": "

#define ARDUINOTRACE_DUMP_PREFIX(line, variable) \
  ":" ARDUINOTRACE_STRINGIFY(line) ": " #variable " = "

// Initializes the Serial port
//
// Use this macro only if you want to call TRACE() at global scope,
// in other cases, call Serial.begin() in your setup() function, as usual.
#define ARDUINOTRACE_INIT(bauds) ARDUINOTRACE_INITIALIZE(__COUNTER__, bauds);

// Adds a trace in the Serial port
//
// Call this macro anywhere, including at global scope.
// However, if you use it at global scope, you need to call ARDUINOTRACE_INIT()
// first, otherwise, the Serial port will not be ready.
#define TRACE()                                           \
  ARDUINOTRACE_PRINT(__COUNTER__, __FILE__,               \
                     ARDUINOTRACE_TRACE_PREFIX(__LINE__), \
                     ARDUINOTRACE_FUNCTION_NAME)

// Prints the value of a variable.
//
// This function will print the name and the value of the variable to the
// Serial. If you use it at global scope, you need to call ARDUINOTRACE_INIT()
// first, otherwise, the Serial port will not be ready.
#define DUMP(variable)                      \
  ARDUINOTRACE_PRINT(__COUNTER__, __FILE__, \
                     ARDUINOTRACE_DUMP_PREFIX(__LINE__, variable), variable)

#define BREAK()                                               \
  do {                                                        \
    ARDUINOTRACE_PRINT(__COUNTER__, __FILE__,                 \
                       ARDUINOTRACE_TRACE_PREFIX(__LINE__),   \
                       "BREAK! (press [enter] to continue)"); \
    ArduinoTrace::pause(ARDUINOTRACE_SERIAL);                 \
  } while (false)

#else  // ie ARDUINOTRACE_ENABLE == 0

#define ARDUINOTRACE_INIT(bauds)
#define TRACE()
#define DUMP(variable)
#define BREAK()

#endif




/*
   This file is part of Arduino_DebugUtils.

   Copyright 2019 ARDUINO SA (http://www.arduino.cc/)

   This software is released under the GNU General Public License version 3,
   which covers the main part of arduino-cli.
   The terms of this license can be found at:
   https://www.gnu.org/licenses/gpl-3.0.en.html

   You can be released from the requirements of the above licenses by purchasing
   a commercial license. Buying such a license is mandatory if you want to modify or
   otherwise use the software for commercial activities involving the Arduino
   software without disclosing the source code of your own applications. To purchase
   a commercial license, send an email to license@arduino.cc.
*/

#ifndef ARDUINO_DEBUG_UTILS_H_
#define ARDUINO_DEBUG_UTILS_H_

/******************************************************************************
   INCLUDE
 ******************************************************************************/

#include <Arduino.h>

#include <stdarg.h>

/******************************************************************************
   CONSTANTS
 ******************************************************************************/

static int const DBG_NONE    = -1;
static int const DBG_ERROR   =  0;
static int const DBG_WARNING =  1;
static int const DBG_INFO    =  2;
static int const DBG_DEBUG   =  3;
static int const DBG_VERBOSE =  4;

void setDebugMessageLevel(int const debug_level);
int  getDebugMessageLevel();

/******************************************************************************
   CLASS DECLARATION
 ******************************************************************************/

class Arduino_DebugUtils {

  public:

    Arduino_DebugUtils();

    void setDebugLevel(int const debug_level);
    int  getDebugLevel() const;

    void setDebugOutputStream(Stream * stream);

    void timestampOn();
    void timestampOff();

    void newlineOn();
    void newlineOff();

    void debugLabelOn();
    void debugLabelOff();

    void formatTimestampOn();
    void formatTimestampOff();

    void print(int const debug_level, const char * fmt, ...);
    void print(int const debug_level, const __FlashStringHelper * fmt, ...);


  private:

    bool      _timestamp_on;
    bool      _newline_on;
    bool      _print_debug_label;
    bool      _format_timestamp_on;
    int       _debug_level;
    Stream *  _debug_output_stream;

    void vPrint(char const * fmt, va_list args);
    void printTimestamp();
    void printDebugLabel(int const debug_level);
    bool shouldPrint(int const debug_level) const;

};

/******************************************************************************
   EXTERN
 ******************************************************************************/

extern Arduino_DebugUtils Debug;

/**************************************************************************************
 * DEFINE
 **************************************************************************************/

#ifndef DEBUG_ERROR
#  define DEBUG_ERROR(fmt, ...) Debug.print(DBG_ERROR, fmt, ## __VA_ARGS__)
#endif

#ifndef DEBUG_WARNING
#  define DEBUG_WARNING(fmt, ...) Debug.print(DBG_WARNING, fmt, ## __VA_ARGS__)
#endif

#ifndef DEBUG_INFO
#  define DEBUG_INFO(fmt, ...) Debug.print(DBG_INFO, fmt, ## __VA_ARGS__)
#endif

#ifndef DEBUG_DEBUG
#  define DEBUG_DEBUG(fmt, ...) Debug.print(DBG_DEBUG, fmt, ## __VA_ARGS__)
#endif

#ifndef DEBUG_VERBOSE
#  define DEBUG_VERBOSE(fmt, ...) Debug.print(DBG_VERBOSE, fmt, ## __VA_ARGS__)
#endif

#endif /* ARDUINO_DEBUG_UTILS_H_ */