
#define LOG_OUT 1

#include <FastLED.h>                                         // FastLED library. Preferably the latest copy of FastLED 2.1.
#if FASTLED_VERSION < 3001000
#error "Requires FastLED 3.1 or later; check github for latest code."
#endif


// PIN definitions
#define PIN_BUT_1     2
#define PIN_BUT_2     3
#define PIN_BUT_3     4
#define BUT_MAX       3


#define PIN_LED_DT_TOP_BAR    5
#define PIN_LED_DT_LEFT_BAR   6     
#define PIN_LED_DT_RIGHT_BAR  7
#define PIN_LED_DT_AMB_LEFT   8
#define PIN_LED_DT_AMB_RIGHT  9

#define PIN_RELAIS_1          10



// LED/STRIPE  definition 

#define LED_TYPE          WS2812B
#define COLOR_ORDER       GRB


#define LED_SIDE_COUNT      60
#define LED_TOP_COUNT       112
#define LED_AMB_LEFT_COUNT  27
#define LED_AMB_RIGHT_COUNT 45
#define LED_MAX             (LED_AMB_LEFT_COUNT + LED_SIDE_COUNT + LED_TOP_COUNT + LED_SIDE_COUNT + LED_AMB_RIGHT_COUNT)

#define STRIPE_AMB_LEFT     0
#define STRIPE_LEFT         1
#define STRIPE_TOP          2
#define STRIPE_RIGHT        3
#define STRIPE_AMB_RIGHT    4
#define STRIPE_MAX          5


#define BLACK CRGB::Black
#define WHITE CRGB::White
#define GREEN CRGB::Green
#define RED   CRGB::Red
#define BLUE  CRGB::Blue
#define PINK  CRGB::Pink


// Initialize changeable global variables.
u8_t max_bright = 255;                                     // Overall brightness definition. It can be changed on the fly.

struct CRGB topBar[LED_TOP_COUNT];
struct CRGB leftBar[LED_SIDE_COUNT];
struct CRGB rightBar[LED_SIDE_COUNT];
struct CRGB ambBarLeft[LED_AMB_LEFT_COUNT];
struct CRGB ambBarRight[LED_AMB_RIGHT_COUNT];
    

int   STRIPE_offset[STRIPE_MAX+1];
int   STRIPE_count[STRIPE_MAX];
struct CRGB* STRIPE_list[STRIPE_MAX];


bool BUT_Pressed[BUT_MAX];
int  BUT_LastState[BUT_MAX];
int  BUT_Debounce[BUT_MAX];
int  BUT_List[BUT_MAX];
char BUT_Code[BUT_MAX];

#define BUT_DEBOUNCE   3

void setup() {
  int i;
  // setup relais
  pinMode(PIN_RELAIS_1,OUTPUT);
  digitalWrite(PIN_RELAIS_1,LOW);

  Serial.begin(115200);                                         // use the serial port
  Serial.println("Setup done");

  STRIPE_init();
  BUT_init();

  digitalWrite(PIN_RELAIS_1,LOW);
  STRIPE_setStripe(STRIPE_AMB_LEFT,BLACK);
  STRIPE_setStripe(STRIPE_LEFT,WHITE);
  STRIPE_setStripe(STRIPE_TOP,BLACK);
  STRIPE_setStripe(STRIPE_RIGHT,WHITE);
  STRIPE_setStripe(STRIPE_AMB_RIGHT,BLACK);

}




void loop() {
  static int i =0;
 
  BUT_loop();

  if (BUT_getPressed(0) == true){
    i++;

    switch(i){
      case 0: 
        digitalWrite(PIN_RELAIS_1,LOW);
        STRIPE_setStripe(STRIPE_AMB_LEFT,BLACK);
        STRIPE_setStripe(STRIPE_LEFT,WHITE);
        STRIPE_setStripe(STRIPE_TOP,BLACK);
        STRIPE_setStripe(STRIPE_RIGHT,WHITE);
        STRIPE_setStripe(STRIPE_AMB_RIGHT,BLACK);
        break;

      case 1:
        digitalWrite(PIN_RELAIS_1,LOW);
        STRIPE_setStripe(STRIPE_AMB_LEFT,BLACK);
        STRIPE_setStripe(STRIPE_LEFT,WHITE);
        STRIPE_setStripe(STRIPE_TOP,WHITE);
        STRIPE_setStripe(STRIPE_RIGHT,WHITE);
        STRIPE_setStripe(STRIPE_AMB_RIGHT,BLACK);
        break;
      
      case 2:
        digitalWrite(PIN_RELAIS_1,HIGH);
        STRIPE_setStripe(STRIPE_AMB_LEFT,BLUE);
        STRIPE_setStripe(STRIPE_LEFT,BLUE);
        STRIPE_setStripe(STRIPE_TOP,BLUE);
        STRIPE_setStripe(STRIPE_RIGHT,BLUE);
        STRIPE_setStripe(STRIPE_AMB_RIGHT,BLUE);
        break;
      
      case 3:
        digitalWrite(PIN_RELAIS_1,HIGH);
        STRIPE_setStripe(STRIPE_AMB_LEFT,RED);
        STRIPE_setStripe(STRIPE_LEFT,RED);
        STRIPE_setStripe(STRIPE_TOP,RED);
        STRIPE_setStripe(STRIPE_RIGHT,RED);
        STRIPE_setStripe(STRIPE_AMB_RIGHT,RED);
        break;

      case 4:
        digitalWrite(PIN_RELAIS_1,HIGH);
        STRIPE_setStripe(STRIPE_AMB_LEFT,GREEN);
        STRIPE_setStripe(STRIPE_LEFT,GREEN);
        STRIPE_setStripe(STRIPE_TOP,GREEN);
        STRIPE_setStripe(STRIPE_RIGHT,GREEN);
        STRIPE_setStripe(STRIPE_AMB_RIGHT,GREEN);
        break;

      case 5:
        digitalWrite(PIN_RELAIS_1,HIGH);
        STRIPE_setStripe(STRIPE_AMB_LEFT,PINK);
        STRIPE_setStripe(STRIPE_LEFT,PINK);
        STRIPE_setStripe(STRIPE_TOP,PINK);
        STRIPE_setStripe(STRIPE_RIGHT,PINK);
        STRIPE_setStripe(STRIPE_AMB_RIGHT,PINK);
        break;

      default:
        i=0;
        break;    

    }
    show_at_max_brightness_for_power();
  }
  delay(50);    
}






void STRIPE_init(){
  Serial.println("STRIPES init()");

  // setup LED
  pinMode(PIN_LED_DT_TOP_BAR,OUTPUT);
  pinMode(PIN_LED_DT_LEFT_BAR,OUTPUT);
  pinMode(PIN_LED_DT_RIGHT_BAR,OUTPUT);
  pinMode(PIN_LED_DT_AMB_LEFT,OUTPUT);
  pinMode(PIN_LED_DT_AMB_RIGHT,OUTPUT);
  

  //add all stripes to LED Driver
  LEDS.addLeds<LED_TYPE, PIN_LED_DT_AMB_LEFT,  COLOR_ORDER>(ambBarLeft,  LED_AMB_LEFT_COUNT);
  LEDS.addLeds<LED_TYPE, PIN_LED_DT_LEFT_BAR,  COLOR_ORDER>(leftBar,     LED_SIDE_COUNT);
  LEDS.addLeds<LED_TYPE, PIN_LED_DT_TOP_BAR,   COLOR_ORDER>(topBar,      LED_TOP_COUNT);
  LEDS.addLeds<LED_TYPE, PIN_LED_DT_RIGHT_BAR, COLOR_ORDER>(rightBar,    LED_SIDE_COUNT);
  LEDS.addLeds<LED_TYPE, PIN_LED_DT_AMB_RIGHT, COLOR_ORDER>(ambBarRight, LED_AMB_RIGHT_COUNT);

  FastLED.setBrightness(max_bright);
  set_max_power_in_volts_and_milliamps(5, 10000);               // FastLED Power management set at 5V, 10A.


  STRIPE_offset[STRIPE_AMB_LEFT]  = 0;
  STRIPE_offset[STRIPE_LEFT]      = LED_AMB_LEFT_COUNT;
  STRIPE_offset[STRIPE_TOP]       = LED_AMB_LEFT_COUNT + LED_SIDE_COUNT;
  STRIPE_offset[STRIPE_RIGHT]     = LED_AMB_LEFT_COUNT + LED_SIDE_COUNT + LED_TOP_COUNT;
  STRIPE_offset[STRIPE_AMB_RIGHT] = LED_AMB_LEFT_COUNT + LED_SIDE_COUNT + LED_TOP_COUNT + LED_SIDE_COUNT ;
  STRIPE_offset[STRIPE_MAX]       = LED_MAX;

  STRIPE_count[STRIPE_AMB_LEFT]  = LED_AMB_LEFT_COUNT;
  STRIPE_count[STRIPE_LEFT]      = LED_SIDE_COUNT;
  STRIPE_count[STRIPE_TOP]       = LED_TOP_COUNT;
  STRIPE_count[STRIPE_RIGHT]     = LED_SIDE_COUNT;
  STRIPE_count[STRIPE_AMB_RIGHT] = LED_AMB_RIGHT_COUNT ;

  STRIPE_list[STRIPE_AMB_LEFT]    = ambBarLeft;
  STRIPE_list[STRIPE_LEFT]        = leftBar;
  STRIPE_list[STRIPE_TOP]         = topBar;
  STRIPE_list[STRIPE_RIGHT]       = rightBar;
  STRIPE_list[STRIPE_AMB_RIGHT]   = ambBarRight;
  
  Serial.println("STRIPES init() done.");

}

void STRIPE_setAll(CRGB color){
  int i,ii;
  for (i = 0;i<STRIPE_MAX;i++){
    for(ii=0;i < STRIPE_count[i];i++){
      STRIPE_list[i][ii]=color;
    }
  }
}

void STRIPE_setStripe(int nr,CRGB color){
  int i;
  if ((nr < 0) || (nr >= STRIPE_MAX)){
    Serial.println("STRIPE_setStripe() invalid index");
    return;
  }
  for(i=0; i < STRIPE_count[nr]; i++){
    STRIPE_list[nr][i] = color;
  }  
  
}

void STRIPE_setLed(int index,CRGB color){
  int i;
  //Reihenfolge   left_AMB  :  left_Bar  :  top_Bar  :  right_Bar  :  right_AMB
  if ((index < 0) || (index >= LED_MAX)){
    Serial.println("STRIPES_setLed() invalid index");
    return;
  }

  for (i=0; i < STRIPE_MAX; i++)
  {
    if (index < STRIPE_offset[i+1]){
      STRIPE_list[i][index-STRIPE_offset[i]] = color;
      return;
    }
  }

  Serial.println("STRIPES_setLed() logic error");
  
}



void BUT_init(){
  int i;
  Serial.println("BUT init()");
  pinMode(PIN_BUT_1,INPUT_PULLUP);
  pinMode(PIN_BUT_2,INPUT_PULLUP);
  pinMode(PIN_BUT_3,INPUT_PULLUP);

  for(i=0;i < BUT_MAX;i++){
    BUT_Pressed[i]   = false;
    BUT_Debounce[i]  = 0;
    BUT_LastState[i] = HIGH;
  }
  BUT_List[0] = PIN_BUT_1;
  BUT_List[1] = PIN_BUT_2;
  BUT_List[2] = PIN_BUT_3;

  BUT_Code[0] = 'A';
  BUT_Code[1] = 'B';
  BUT_Code[2] = 'C';

  Serial.println("BUT init() done.");

}


void BUT_loop(){
  int i;
  int state;
  for (i=0;i < BUT_MAX; i++){
    state = digitalRead(BUT_List[i]);

    if (BUT_LastState[i] == HIGH){
      // button was NOT pressed
      if(state == LOW){
        // now pressed
        BUT_Debounce[i]++;
        if (BUT_Debounce[i] > BUT_DEBOUNCE){
          // valid press
          Serial.println("but pressed:" + BUT_Code[i]);
          BUT_Debounce[i] = 0;
          BUT_LastState[i] = LOW;
        }
      } else {
        // debounce !!
        BUT_Debounce[i] = 0; 
      }
    } else {
      // button was pressed
      if (state == HIGH){
        // now released again
        BUT_Debounce[i]++;
        if (BUT_Debounce[i] > BUT_DEBOUNCE){
          // valid release
          Serial.println("but released:" + BUT_Code[i]);
          BUT_Debounce[i] = 0;
          BUT_LastState[i] = HIGH;
          BUT_Pressed[i] = true;
        }
      }
    }
  }
}

bool BUT_getPressed(int nr){
  bool temp;
  if (nr > BUT_MAX){
   return false;
  }
  temp = BUT_Pressed[nr];
  BUT_Pressed[nr] = false;
  return temp;
}
